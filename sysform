#!/bin/bash

#system
# |
# +--overlays (or just listed in a profile along with post run procedures)
# +--overlays.d
# +--packages

# TODO: consolidate into a single profile file
# rename overlays.d to just overlay
# need a custom function in the profile?

#system
# |
# +--overlay
# +--profile

# ----------------------------------------------------------------------
# DEFAULTS
# ----------------------------------------------------------------------
CMD=$(basename $0)
TEMP_PATH=/tmp/$CMD
CONFIG_FILENAME=profile
OVERLAY_FILENAME=overlay
PACKAGES_FILENAME=packages
AUR_FILENAME=aur
OVERLAY_DIRNAME=overlay.d
DEFAULT_CONFIG_PATH="$XDG_CONFIG_HOME/$CMD/$HOSTNAME"
. $(dirname $0)/lib/common

# ----------------------------------------------------------------------
# DECLARATIONS
# ----------------------------------------------------------------------
declare -A groups
declare -A packages_official_grouped_missing
declare -A packages_official_grouped_removed
declare -A packages_official
declare -A packages_aur
declare -A overlay_files
declare -A missing_official_from
declare -A missing_aur_from

# ----------------------------------------------------------------------
# COMMAND LINE OPTIONS, RUNTIME OPTION REPORT VALUES & HELP
# ----------------------------------------------------------------------
option_config_update=(
[key]="c"
[value_state]="false"
[value_ifset]="true"
[report]="running in report only mode (will report difference between system and config)"
[report_ifset]="update mode; $CMD will update config files (use with backup to preserve existing overlay files)"
[usage_summary]="Update configuration files in config directory. Can be used in conjunction with the backup option"
)
option_config_path=(
[key]="p"
[value_state]="$DEFAULT_CONFIG_PATH"
[value_ifset]=":path"
[report]="default config path used"
[report_ifset]="custom config path set"
[usage_summary]="Set custom config *directory* path. Default for this system is $DEFAULT_CONFIG_PATH"
)
option_backup=(
[key]="b"
[value_state]="false"
[value_ifset]="true"
[report]="backups off; files will be overwritten"
[report_ifset]="backups on; files will be saved in place with backup suffix"
[usage_summary]="Backup files when copying new file to existing path."
)
option_system_update=(
[key]="s"
[value_state]="false"
[value_ifset]="true"
[report]="system file conform off; no live system files will be written to during this procedure."
[report_ifset]="system file conform on; live system files *will* be overwritten, recommend using this with the backup option."
[usage_summary]="Update system files with current sysform config overlay files. Should be used with the backup option if you want to preserve existing files."
)
option_force=(
[key]="f"
[value_state]="false"
[value_ifset]="true"
[report]="force mode off; queries will be presented prior to file write operations."
[report_ifset]="force mode on; no queries will be presented; CAUTION"
[usage_summary]="Force all write operations; no queries will be given, use with caution and consider use of the backup option. Applies to both config and system updates."
)
option_git_update=(
[key]="g"
[value_state]="false"
[value_ifset]="true"
[report]="git update off; no git push after config update"
[report_ifset]="git update on; git push will occur after config update"
[usage_summary]="Git update; if sysform config directory being updated is a git repository, an automated git add, commit, and push will occur."
)
option_pacman_update=(
[key]="y"
[value_state]="false"
[value_ifset]="true"
[report]="do not update pacman repo db prior to running"
[report_ifset]="update pacman repo db prior to running"
[usage_summary]="pacman db update"
)

# ----------------------------------------------------------------------
# PROCESS OPTIONS
# ----------------------------------------------------------------------
process_opts
$(istrue $BACKUP) && backup_mode="simple" || backup_mode="none"
if istrue $CONFIG_UPDATE && istrue $SYSTEM_UPDATE
then
    echo "Please select only one of -c / -s (config/system update)"
    exit 1
fi

# ----------------------------------------------------------------------
# CONFIG DIRECTORY & FILE
# ----------------------------------------------------------------------
# config directory
if [[ ! -d "$CONFIG_PATH" ]]
then
    if istrue $UPDATE; then
        mkdir -p "$CONFIG_PATH"
    else
        echo "No config directory present; run again in update mode to automatically create it at $CONFIG_PATH."
        usage
        exit 0
    fi
fi
# config file
[[ -f "$CONFIG_PATH/$CONFIG_FILENAME" ]] && source "$CONFIG_PATH/$CONFIG_FILENAME"

# ----------------------------------------------------------------------
# TEMP: "SOURCE" CONFIG
# ----------------------------------------------------------------------
overlay <<EOF
/boot/grub/menu.lst
/etc/acpi/handler.sh
/etc/rc.conf
/etc/rc.local
/etc/modprobe.d/modprobe.conf
/etc/wpa_supplicant.conf
/etc/nofile
EOF
packages <<EOF
acpi acpid acpitool aif alsa-utils augeas cowsay cpufrequtils curl dialog 
firefox gamin git gstreamer0.10-base-plugins ifplugd iw mesa mesa-demos netcfg 
openssh rfkill rsync rxvt-unicode sudo terminus-font vim wpa_actiond 
wpa_supplicant_gui xmobar xorg-server-utils xorg-twm xorg-utils xorg-xclock 
xorg-xinit xterm yacpi yajl youtube-dl zsh
EOF
aur <<EOF
flashplugin-beta freetype2-git-infinality git-annex haskell-json 
package-query-git wpa_auto xmonad-contrib-darcs xmonad-darcs yaourt-git testaur
EOF

# ----------------------------------------------------------------------
# UPDATE PACKAGE DB
# ----------------------------------------------------------------------
if istrue $PACMAN_UPDATE
then
    sudo pacman -Sy
fi

# ----------------------------------------------------------------------
# DETECT GROUPS
# ----------------------------------------------------------------------
groups[potential]=$(pacman -Qg | awk '{print $1}' | sort | uniq)
echo -e "$HR\nDETECTING INSTALLED GROUPS:"
for groupname in ${groups[potential]}
do
    break # TODO DEBUG
    # get percentage of group already installed
    # sort and uniq are required as there can be duplicate package reporting if 
    # testing repos are live, for instance
    #echo -n "Checking $groupname: "
    count_local=$(pacman -Qgq $groupname | sort | uniq | wc -l)
    count_repo=$(pacman -Sgq $groupname | sort | uniq | wc -l)
    threshold=12
    score=$(echo $((($count_repo*10)/$count_local)))
    #echo -n "$count_local of $count_repo installed "
    if [[ $score -le $threshold ]]
    then
        groups[detected]+="$groupname "
        echo -n "$groupname "
        #echo "(scored $score; marked INSTALLED)"
    else
        #echo "(scored $score)"
        :
    fi
done
#echo "Groups detected: ${groups[detected]}"
echo
groups[detected]="base base-devel xfce4 xorg xorg-apps xorg-drivers xorg-fonts" # TODO DEBUG
groups[live]="${groups[detected]}"

# ----------------------------------------------------------------------
# GROUP STATE
# ----------------------------------------------------------------------
# group check
#echo -en "$HR\nPackage groups installed: "
#echo ${groups[live]} 
#echo
for groupname in ${groups[live]}
do
    break # TODO DEBUG
    grouprepo="$(pacman -Sgq $groupname)"; grouplocal="$(pacman -Qgq $groupname)"
    packages_official_grouped_missing[$groupname]=$(compare "$grouprepo" "$grouplocal")
    packages_official_grouped_removed[$groupname]=$(compare "$grouplocal" "$grouprepo")
    [[ -n ${packages_official_grouped_missing[$groupname]} ]] \
        && echo $groupname group has new packages that can be installed: ${packages_official_grouped_missing[$groupname]}
    [[ -n ${packages_official_grouped_removed[$groupname]} ]] \
        && echo $groupname group has removed packages\; the following can be removed locally: ${packages_official_grouped_removed[$groupname]}
    [[ -z ${packages_official_grouped_missing[$groupname]} && -z ${packages_official_grouped_removed[$groupname]} ]] \
        && echo $groupname package list is up to date
done

# ----------------------------------------------------------------------
# PACKAGE STATE
# ----------------------------------------------------------------------
packages_official[live]="$(compare "$(compare "$(pacman -Qeq)" "$(pacman -Qmq)")" "$(pacman -Qgq ${groups[live]})")"
packages_aur[live]="$(common "$(pacman -Qeq)" "$(pacman -Qmq)")"
echo -e "$HR\nOFFICIAL PACKAGES (EXCL. DEPENDENCIES, NO GROUP PACKAGES):"
echo ${packages_official[live]}
echo -e "$HR\nAUR PACKAGES (EXCL. DEPENDENCIES):"
echo ${packages_aur[live]}

missing_official_from[system]="$(compare "${packages_official[file]}" "${packages_official[live]}")"
missing_official_from[config]="$(compare "${packages_official[live]}" "${packages_official[file]}")"
missing_aur_from[system]="$(compare "${packages_aur[file]}" "${packages_aur[live]}")"
missing_aur_from[config]="$(compare "${packages_aur[live]}" "${packages_aur[file]}")"
[[ -n ${missing_official_from[system]} ]] && echo -e "$HR\nOFFICIAL PACKAGES MISSING FROM SYSTEM:\n"$(echo ${missing_official_from[system]})
[[ -n ${missing_official_from[config]} ]] && echo -e "$HR\nOFFICIAL PACKAGES MISSING FROM CONFIG:\n"$(echo ${missing_official_from[config]})
[[ -n ${missing_aur_from[system]} ]] && echo -e "$HR\nAUR PACKAGES MISSING FROM SYSTEM:\n"$(echo ${missing_aur_from[system]})
[[ -n ${missing_aur_from[config]} ]] && echo -e "$HR\nAUR PACKAGES MISSING FROM CONFIG:\n"$(echo ${missing_aur_from[config]})

# ----------------------------------------------------------------------
# OVERLAY FILES STATE
# ----------------------------------------------------------------------
DEFAULT_ATTRIBS="644 root root"
_IFS=$IFS; IFS=$'\n'
#while read line
for line in ${overlay_files[file]}
do
    _path=$(echo -n $line | awk '{print $1}')
    _attribs=$(echo -n $line | awk '{print $2,$3,$4}')
    [[ -e $_path ]] && _live_attribs=$(stat -c '%a %U %G' $_path)
    [[ -z $_attribs && -e $_path ]] && _attribs=$_live_attribs
    [[ -z $_attribs ]] && _permissions=$DEFAULT_ATTRIBS
    overlay_files[reviewed]+="$_path $_attribs\n"
    [[ -e $_path ]] && overlay_files[live]+="$_path $_live_attribs\n" || overlay_files[live]+="$_path $_attribs\n"
    overlay_files[paths]+="$_path\n"
done
overlay_files[file]="$(echo -e "${overlay_files[reviewed]}" | sed '/^$/d')"
overlay_files[live]="$(echo -e "${overlay_files[live]}" | sed '/^$/d')"
overlay_files[paths]="$(echo -e "${overlay_files[paths]}" | sed '/^$/d')"
IFS=$_IFS

# ----------------------------------------------------------------------
# ACTION: CONFIG UPDATE
# ----------------------------------------------------------------------
if istrue $CONFIG_UPDATE
then
    if ! istrue $FORCE
    then
        echo -e "$HR\nWRITE WARNING:"
        echo $HR
        echo "The following files will be copied from the system to the config overlay directory ($CONFIG_PATH/$OVERLAY_DIRNAME)."
        echo
        echo "${overlay_files[paths]}"
        echo
        echo -n "Proceed? (y/n) "
        read answer; if ! istrue $answer; then exit 0; fi 
    fi
    #TODO: offer diff report option, consider precheck diff

    _IFS=$IFS; IFS=$'\n'
    for line in ${overlay_files[live]}
    do
        _path=$(echo -n $line | awk '{print $1}')
        if [[ -d "$CONFIG_PATH/$OVERLAY_DIRNAME" ]]
        then
        install -dCD --backup=$backup_mode -S"-$CMD-$(date +%F-%s)" "$_path" "$CONFIG_PATH/$OVERLAY_DIRNAME/${_path#/}"
        else
        install -CD --backup=$backup_mode -S"-$CMD-$(date +%F-%s)" "$_path" "$CONFIG_PATH/$OVERLAY_DIRNAME/${_path#/}"
        fi
    done
    IFS=$_IFS
fi

#TODO: we've already recorded possible new or removed packages on both sides 
#but we need to prompt the user to choose what to do

rm -rf $TEMP_PATH; mkdir $TEMP_PATH
echo "${overlay_files[live]}" > $TEMP_PATH/$OVERLAY_FILENAME
echo "${packages_official[live]}" > $TEMP_PATH/$PACKAGES_FILENAME
echo "${packages_aur[live]}" > $TEMP_PATH/$AUR_FILENAME
for _filename in $OVERLAY_FILENAME $PACKAGES_FILENAME $AUR_FILENAME
do
    install -CD --backup=$backup_mode -S"-$CMD-$(date +%F-%s)" "$TEMP_PATH/$_filename" "$CONFIG_PATH/$_filename"
done

exit


# ----------------------------------------------------------------------
# ACTION: SYSTEM UPDATE
# ----------------------------------------------------------------------
if istrue $SYSTEM_UPDATE
then
    if ! istrue $FORCE
    then
        echo -e "$HR\nWRITE WARNING:"
        echo $HR
        echo "The following files will be copied from the config overlay directory ($CONFIG_PATH/$OVERLAY_DIRNAME) to the live system:"
        echo
        echo "${overlay_files[paths]}"
        echo
        echo -n "Proceed? (y/n) "
        read answer; if ! istrue $answer; then exit 0; fi 
    fi
    #TODO: offer diff report option, consider precheck diff

    _IFS=$IFS; IFS=$'\n'
    for line in ${overlay_files[file]}
    do
        _path=$(echo -n $line | awk '{print $1}')
        _perms=$(echo -n $line | awk '{print $2}')
        _owner=$(echo -n $line | awk '{print $3}')
        _group=$(echo -n $line | awk '{print $4}')
        if [[ -d "$CONFIG_PATH/$OVERLAY_DIRNAME" ]]
        then
        install -dCD --backup=$backup_mode -S"-$CMD-$(date +%F-%s)" -g${_group} -o${_owner} -m${_mode} "$CONFIG_PATH/$OVERLAY_DIRNAME/${_path#/}" "$_path"
        else
        install -CD --backup=$backup_mode -S"-$CMD-$(date +%F-%s)" -g${_group} -o${_owner} -m${_mode} "$CONFIG_PATH/$OVERLAY_DIRNAME/${_path#/}" "$_path"
        fi
    done
    IFS=$_IFS
fi
exit

# ----------------------------------------------------------------------
# ACTION: REPORT
# ----------------------------------------------------------------------
echo -e "$HR\nOVERLAY FILES LIST:"
echo -e "${overlay_files[live]}"
echo "OVERLAY FILE $HR"
echo "${overlay_files[file]}"
echo "OVERLAY LIVE $HR"
echo "${overlay_files[live]}"
exit

# ----------------------------------------------------------------------
# REGEN
# ----------------------------------------------------------------------
# can override in a config file
regen






# ----------------------------------------------------------------------
# ----------------------------------------------------------------------
# ----------------------------------------------------------------------

# install yaourt

# reinstall config files

# final regen of any required files (mkinicpio, grub2, etc.)

# git commit & push on update? -g option?
